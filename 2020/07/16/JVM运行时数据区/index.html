<!DOCTYPE html>
<html lang="zh-cmn-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>运行时数据区(Run-Time Data Areas) | Boring&#39;s Blog</title>
  
    <link rel="icon" href="/images/icon.png">
  
  
  
  <link href="https://https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" rel="stylesheet">
  <!--link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css"-->
  
<link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css">

  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

<body>
<!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="Shell">
    <aside class='SideBar'>
    <section class='avatar' style="background-image: url()">
        <div class='av-pic' style="background-image: url(/images/icon.png)">
        </div>
    </section>
    <section class='menu'>
        <div>Boring&#39;s Blog</div>
        
            <div>Life is boring, so go to study.</div>
        
        <ul>
          
            <a href="/" class="Btn">
              <li>Home</li>
            </a>  
          
            <a href="/tags/" class="Btn">
              <li>Tags</li>
            </a>  
          
            <a href="/archives/" class="Btn">
              <li>Archive</li>
            </a>  
          
        </ul>
    </section>
    <section class="media">
        
    </section>
</aside>

    <div class="container">
        <div data-pager-shell>
            <div>
  <article class='ContentView'>
    <header class='PageTitle'>
        <h1>运行时数据区(Run-Time Data Areas)</h1>
    </header>

    <section>
      <center><img src="/2020/07/16/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/JVM_Run-Time_Data_Areas.png" class="" title="JVM运行时数据区"></center>
<!-- ![JVM运行时数据区](JVM_Run-Time_Data_Areas.png "JVM运行时数据区") -->
<p>JVM定义了在程序运行期间使用的各种运行时数据区。其中一些区域随JVM启动而创建，JVM退出而销毁。其他区域是每个线程私有的。随线程创建而创建，线程退出而销毁。</p>
<!-- > The Java Virtual Machine defines various run-time data areas that are used during execution of a program. Some of these data areas are created on Java Virtual Machine start-up and are destroyed only when the Java Virtual Machine exits. Other data areas are per thread. Per-thread data areas are created when a thread is created and destroyed when the thread exits. -->
<a id="more"></a>
<h2 id="程序计数器the-pc-register"><a class="markdownIt-Anchor" href="#程序计数器the-pc-register"></a> 程序计数器(The pc Register)</h2>
<p>JVM支持多线程。每个线程有其自己的程序计数寄存器(program counter register)。在任何时间，JVM线程都在执行单一的方法。如果这个方法不是本地方法(native)，程序计数器会保存当前执行的JVM指令地址。如果执行的是本地方法(native)，JVM程序计数器的值是未定义。JVM的程序计数器足够大可以在特定平台上保存returnAddress或本地指针。</p>
<!-- > The Java Virtual Machine can support many threads of execution at once. Each Java Virtual Machine thread has its own `pc` (program counter) register. At any point, each Java Virtual Machine thread is executing the code of a single method, namely the current method for that thread. If that method is not `native`, the pc register contains the address of the Java Virtual Machine instruction currently being executed. If the method currently being executed by the thread is `native`, the value of the Java Virtual Machine's pc register is undefined. The Java Virtual Machine's pc register is wide enough to hold a `returnAddress` or a native pointer on the specific platform. -->
<h2 id="jvm栈java-virtual-machine-stacks"><a class="markdownIt-Anchor" href="#jvm栈java-virtual-machine-stacks"></a> JVM栈(Java Virtual Machine Stacks)</h2>
<p>每个JVM线程都有一个私有的Java虚拟机栈，与线程同时创建。JVM虚拟机栈存储的栈帧结构为：</p>
<ul>
<li>局部变量表</li>
<li>操作数栈</li>
<li>动态连接</li>
<li>方法返回地址
<ul>
<li>正常完成出口</li>
<li>异常完成出口</li>
</ul>
</li>
</ul>
<p>JVM栈类似于常规语言(例如C)的堆栈：它保存局部变量和部分结果，并且在方法调用和返回中起作用。由于JVM栈除了push和pop栈帧外并不会直接操作栈帧，所以栈帧可能从堆上分配。JVM栈的内存不许要是连续的。</p>
<p>Java虚拟机规范允许Java虚拟机栈具有固定的大小，或者根据要求动态扩展和收缩。如果Java虚拟机栈的大小是固定的，则每个线程创建时可以独立选择它们的大小。</p>
<p>Java虚拟机的实现可以让程序员或用户控制Java虚拟机栈的初始大小，并且在动态扩展大小的Java虚拟机栈的情况下，可以控制最大和最小值。</p>
<p>以下这些异常与Java虚拟机栈相关：</p>
<ul>
<li>如果线程需要的Java虚拟机栈大小比允许的更大，则抛出<code>StackOverflowError</code>。</li>
<li>如果可以动态扩展Java虚拟机栈，并且尝试进行扩展，但是没有足够的内存满足；或者没有足够的内存为新线程创建Java虚拟机栈，则抛出<code>OutOfMemoryError</code>。</li>
</ul>
<h2 id="堆heap"><a class="markdownIt-Anchor" href="#堆heap"></a> 堆(Heap)</h2>
<p>Java虚拟机有一个所有线程共享的堆。堆是运行时数据区，从中分配所有类的实例和数组的内存。</p>
<p>堆随着JVM的启动创建。堆存储的对象被垃圾回收器(GC)整理；对象永远不会被显示释放。Java虚拟机不知定特定的垃圾回收器，并且可以根据实现者的系统要求选择垃圾回收技术。堆的大小可以是固定的，也可以根据要求进行计算扩展和收缩。堆的内存不必是连续的。</p>
<p>Java虚拟机的实现可以让程序员或用户控制堆的初始大小，并且堆内存如果可以动态地扩展或收缩，则可以控制堆内存的最大和最小值。</p>
<p>以下这些异常与堆相关：</p>
<ul>
<li>如果计算需要的堆内存大于GC可以提供的，则抛出<code>OutOfMemoryError</code>。</li>
</ul>
<h2 id="方法区method-area"><a class="markdownIt-Anchor" href="#方法区method-area"></a> 方法区(Method Area)</h2>
<p>JVM具有一个所有线程共享的方法区。方法区类似与常规语言的编译后代码的存储区域，或者类似与操作系统线程的“text”段(代码段)。它存储每个类的结构例如运行时常量池，字段和方法数据，以及方法和构造器的代码，包括用于类、实例、接口初始化的特殊方法(<code>&lt;init&gt;</code>)。</p>
<p>方法区是在JVM启动时创建的。尽管方法区在逻辑上是堆的一部分，但是简单的实现可以选择不进行垃圾回收或对其压缩。Java虚拟机规范没有规定方法区的位置，或者管理已编译的代码的策略。</p>
<p>方法区的大小可以是固定的，或者可以根据需要进行计算扩展和收缩。方法区的内存不必是连续的。</p>
<p>Java虚拟机的实现可让程序员或用户控制方法区的初始大小，以及在方法区大小可变的情况下，可以控制最大和最小值。</p>
<p>以下这些异常与方法区相关：</p>
<p>如果方法区中的内存不满足分配请求，则抛出<code>OutOfMemoryError</code>。</p>
<h2 id="运行时常量池run-time-constant-pool"><a class="markdownIt-Anchor" href="#运行时常量池run-time-constant-pool"></a> 运行时常量池(Run-Time Constant Pool)</h2>
<p>运行时常量池是class文件中类或接口的<code>constant_pool</code>表的运行时表示。它包含几种常量，范围从编译时已知的数字到运行时解析的方法和字段引用。运行时常量池的功能类似与常规编程语言的符号表，尽管它包含的符号范围比典型的符号表还大。</p>
<p>每个运行时常量池都是从方法区中分配的。当JVM创建类或接口时，为其分配运行时常量池。</p>
<p>以下异常与类或接口的运行时常量池的构造有关：</p>
<ul>
<li>创建类或接口时，如果运行时常量池的构造需要的内存超过方法区中可用的内存，则抛出<code>OutOfMemoryError</code>。</li>
</ul>
<h2 id="本地方法栈native-method-stacks"><a class="markdownIt-Anchor" href="#本地方法栈native-method-stacks"></a> 本地方法栈(Native Method Stacks)</h2>
<p>Java虚拟机的实现可以使用传统的堆栈（俗称“ C堆栈”）来支持本地方法（不是Java编写的方法）。本地方法也被用于使用诸如C之类的语言来解释Java虚拟机指令集的解释器实现。Java虚拟机的实现不能加载本地方法并，且自身不依赖于常规堆栈，因此无需提供本地方法栈。如果提供，通常在创建每个线程时为其分配本地方法栈。</p>
<p>该规范允许本地方法栈具有固定大小，或者根据要求动态计算扩展和收缩。如果本地方法栈的大小固定，则在创建每个本地方法栈时可以独立选择其大小。</p>
<p>Java虚拟机实现可以让程序员或用户控制提供的本地方法栈的初始大小，并且在本地方法栈大小可变化的情况下，可以控制最大和最小值。</p>
<p>以下异常条件与本地方法栈相关：</p>
<ul>
<li>如果线程中的计算所需的本地方法栈超出允许的范围，则Java虚拟机将引发<code>StackOverflowError</code>。</li>
<li>如果可以动态扩展本地方法栈并尝试进行本地方法栈的扩展，但是不能提供足够的内存；或者可以不能提供足够的内存来为新线程的创建初始本地方法栈，则Java虚拟机将引发<code>OutOfMemoryError</code>。</li>
</ul>


      

    </section>
    
      <section class='ArticleMeta'>
          <div>
            发布于&nbsp;
            <time datetime="2020-07-16T08:45:11.000Z" itemprop="datePublished">
              2020-07-16
            </time>
          </div>
          
            <div>
              tags: 
  <li class="meta-text">
  { <a href="/tags/Java/">Java</a> }
  </li>

  <li class="meta-text">
  { <a href="/tags/JVM/">JVM</a> }
  </li>


            </div>
          
      </section>
    
    
</article>

  
</div>

            <footer>
    <div>© 2020 - Zhang BaoYun </div>
    <div>
        <span>
            Powered by <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a>
        </span>
        ,
        <span>
            Theme - <a href="https://github.com/nameoverflow/hexo-theme-icalm" target="_blank" rel="noopener">Icalm</a>
        </span>
    </div>
</footer>

        </div>
    </div>
</div>

<script src="/js/pager/dist/singlepager.js"></script>

<script>
var sp = new Pager('data-pager-shell')

</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>